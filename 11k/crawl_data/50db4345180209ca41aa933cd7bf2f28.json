{"url": "http://www.ics.uci.edu/~eppstein/PADS/Automata.py", "word_count": 2100, "words": ["\"\"\"Automata.py", "Manipulation", "of", "and", "conversions", "between", "regular", "expressions,", "deterministic", "finite", "automata,", "and", "nondeterministic", "finite", "automata.", "D.", "Eppstein,", "UC", "Irvine,", "November", "2003.", "\"\"\"", "from", "Util", "import", "arbitrary_item", "import", "sys", "import", "operator", "import", "unittest", "from", "PartitionRefinement", "import", "PartitionRefinement", "from", "Sequence", "import", "Sequence", "#", "Hack", "for", "Python", "3", "compatibility", "try:", "unicode", "except:", "unicode", "=", "str", "class", "LanguageError(Exception):", "pass", "def", "Language(A):", "\"\"\"Convert", "automaton", "A", "into", "an", "object", "describing", "its", "language.", "This", "is", "distinct", "from", "class", "RegularLanguage", "in", "case", "we", "want", "to", "later", "add", "other", "types", "of", "automaton", "and", "nonregular", "languages.", "\"\"\"", "return", "A.language()", "class", "RegularLanguage:", "\"\"\"Object", "representing", "the", "language", "recognized", "by", "a", "DFA", "or", "NFA.", "Available", "operations", "are", "testing", "whether", "a", "string", "is", "in", "the", "language,", "logical", "combinations,", "and", "subset", "and", "equality", "testing.", "\"\"\"", "def", "__init__(self,arg):", "if", "isinstance(arg,FiniteAutomaton):", "self.recognizer", "=", "arg", "elif", "isinstance(arg,(str,unicode)):", "self.recognizer", "=", "RegExp(arg)", "else:", "raise", "LanguageError(\"Unrecognized", "constructor", "for", "RegularLanguage\")", "def", "__contains__(self,inputsequence):", "return", "self.recognizer(inputsequence)", "def", "__eq__(self,other):", "if", "not", "isinstance(other,RegularLanguage):", "return", "None", "return", "self.recognizer.minimize()", "==", "other.recognizer.minimize()", "def", "__ne__(self,other):", "return", "not", "(self", "==", "other)", "def", "__le__(self,other):", "return", "not(self", "&~", "other)", "def", "__ge__(self,other):", "return", "not(other", "&~", "self)", "def", "__lt__(self,other):", "return", "self", "<=", "other", "and", "self", "!=", "other", "def", "__gt__(self,other):", "return", "self", ">=", "other", "and", "self", "!=", "other", "def", "__invert__(self):", "\"\"\"Complement", "(with", "respect", "to", "alphabet)", "of", "language.\"\"\"", "return", "Language(self.recognizer.complement())", "def", "__and__(self,other):", "\"\"\"Intersection", "of", "two", "languages", "with", "the", "same", "alphabet.\"\"\"", "if", "not", "isinstance(other,RegularLanguage):", "raise", "LanguageError(\"Unable", "to", "intersect", "nonregular", "language\")", "return", "Language(self.recognizer.intersection(other.recognizer))", "def", "__or__(self,other):", "\"\"\"Union", "of", "two", "languages", "with", "the", "same", "alphabet.\"\"\"", "if", "not", "isinstance(other,RegularLanguage):", "raise", "LanguageError(\"Unable", "to", "intersect", "nonregular", "language\")", "return", "Language(self.recognizer.union(other.recognizer))", "def", "__xor__(self,other):", "\"\"\"Symmetric", "difference", "of", "two", "languages", "with", "the", "same", "alphabet.\"\"\"", "if", "not", "isinstance(other,RegularLanguage):", "raise", "LanguageError(\"Unable", "to", "intersect", "nonregular", "language\")", "return", "Language(self.recognizer.symmetricDifference(other.recognizer))", "def", "__nonzero__(self):", "\"\"\"Is", "this", "the", "empty", "language?\"\"\"", "for", "x", "in", "self.recognizer.states():", "if", "x.isfinal():", "return", "True", "return", "False", "class", "FiniteAutomaton:", "\"\"\"Base", "class", "for", "DFA", "and", "NFA.", "This", "class", "should", "not", "be", "instantiated", "on", "its", "own,", "but", "dispatches", "methods", "that", "are", "appropriate", "to", "both", "types", "of", "automaton", "by", "calling", ".asDFA()", "or", ".asNFA()", "to", "convert", "the", "automaton", "to", "the", "appropriate", "type.", "All", "automaton", "instances", "should", "include", "the", "following", "instance", "variables", "and", "methods:", "-", "x.initial:", "initial", "state", "(for", "DFA)", "or", "set", "of", "states", "(for", "NFA)", "-", "x.alphabet:", "set", "of", "input", "symbols", "accepted", "by", "the", "automaton", "-", "x.transition(state,symbol):", "result", "of", "transition", "function,", "either", "a", "single", "state", "(for", "a", "DFA)", "or", "set", "of", "states", "(for", "an", "NFA)", "-", "x.isfinal(state):", "whether", "the", "state", "is", "an", "accepting", "state", "-", "x.asDFA():", "return", "an", "equivalent", "DFA", "-", "x.asNFA():", "return", "an", "equivalent", "NFA", "\"\"\"", "initial", "=", "alphabet", "=", "transition", "=", "isfinal", "=", "asDFA", "=", "asNFA", "=", "None", "def", "__len__(self):", "\"\"\"How", "many", "states", "does", "this", "automaton", "have?\"\"\"", "return", "len(list(self.states()))", "def", "__call__(self,symbols):", "\"\"\"Test", "whether", "sequence", "of", "symbols", "is", "accepted", "by", "the", "DFA.\"\"\"", "return", "self.asDFA()(symbols)", "def", "language(self):", "\"\"\"Form", "language", "object", "for", "language", "recognized", "by", "automaton.\"\"\"", "return", "RegularLanguage(self)", "def", "states(self):", "\"\"\"Generate", "all", "states", "reachable", "from", "initial", "state.\"\"\"", "return", "self.asNFA().states()", "def", "pprint(self,output=sys.stdout):", "\"\"\"Pretty-print", "this", "automaton", "to", "an", "output", "stream.\"\"\"", "return", "self.asNFA().pprint(output)", "def", "minimize(self):", "\"\"\"Return", "smallest", "equivalent", "DFA.\"\"\"", "return", "_MinimumDFA(self.asDFA())", "def", "reverse(self):", "\"\"\"Construct", "NFA", "for", "reversal", "of", "original", "NFA's", "language.\"\"\"", "return", "_ReverseNFA(self.asNFA())", "def", "renumber(self,offset=0):", "\"\"\"Replace", "complicated", "state", "objects", "by", "small", "integers.\"\"\"", "return", "_RenumberNFA(self.asNFA(),offset=offset)", "def", "RegExp(self):", "\"\"\"Return", "equivalent", "regular", "expression.\"\"\"", "return", "self.asNFA().RegExp()", "def", "complement(self):", "\"\"\"Make", "automaton", "recognizing", "complement", "of", "given", "automaton's", "language.\"\"\"", "return", "_ComplementDFA(self.asDFA())", "def", "union(self,other):", "\"\"\"Make", "automaton", "recognizing", "union", "of", "two", "automata's", "languages.\"\"\"", "return", "_ProductDFA(self.asDFA(),other.asDFA(),operator.or_)", "def", "intersection(self,other):", "\"\"\"Make", "automaton", "recognizing", "union", "of", "two", "automata's", "languages.\"\"\"", "return", "_ProductDFA(self.asDFA(),other.asDFA(),operator.and_)", "def", "symmetricDifference(self,other):", "\"\"\"Make", "automaton", "recognizing", "union", "of", "two", "automata's", "languages.\"\"\"", "return", "_ProductDFA(self.asDFA(),other.asDFA(),operator.xor)", "class", "DFA(FiniteAutomaton):", "\"\"\"Base", "class", "for", "deterministic", "finite", "automaton.", "Subclasses", "are", "responsible", "for", "filling", "out", "the", "details", "of", "the", "initial", "state,", "alphabet,", "and", "transition", "function.", "\"\"\"", "def", "asDFA(self):", "return", "self", "def", "asNFA(self):", "return", "_NFAfromDFA(self)", "def", "__call__(self,symbols):", "\"\"\"Test", "whether", "sequence", "of", "symbols", "is", "accepted", "by", "the", "DFA.\"\"\"", "state", "=", "self.initial", "for", "symbol", "in", "symbols:", "if", "symbol", "not", "in", "self.alphabet:", "raise", "LanguageError(\"Symbol", "\"", "+", "repr(symbol)", "+", "\"", "not", "in", "input", "alphabet\")", "state", "=", "self.transition(state,symbol)", "return", "self.isfinal(state)", "def", "__eq__(self,other):", "\"\"\"Report", "whether", "these", "two", "DFAs", "have", "equivalent", "states.\"\"\"", "if", "not", "isinstance(other,DFA)", "or", "len(self)", "!=", "len(other)", "\\", "or", "self.alphabet", "!=", "other.alphabet:", "return", "False", "equivalences", "=", "{self.initial:other.initial}", "unprocessed", "=", "[self.initial]", "while", "unprocessed:", "x", "=", "unprocessed.pop()", "y", "=", "equivalences[x]", "for", "c", "in", "self.alphabet:", "xc", "=", "self.transition(x,c)", "yc", "=", "other.transition(y,c)", "if", "xc", "not", "in", "equivalences:", "equivalences[xc]", "=", "yc", "unprocessed.append(xc)", "elif", "equivalences[xc]", "!=", "yc:", "return", "False", "return", "True", "def", "__ne__(self,other):", "\"\"\"Report", "whether", "these", "two", "DFAs", "have", "equivalent", "states.\"\"\"", "return", "not", "(self", "==", "other)", "class", "NFA(FiniteAutomaton):", "\"\"\"Base", "class", "for", "nondeterministic", "finite", "automaton.", "Subclasses", "are", "responsible", "for", "filling", "out", "the", "details", "of", "the", "initial", "state,", "alphabet,", "and", "transition", "function.", "Note", "that", "the", "NFAs", "defined", "here", "do", "not", "allow", "epsilon-transitions.", "Results", "of", "self.initial", "and", "self.transition", "are", "assumed", "to", "be", "represented", "as", "frozenset", "instances.", "\"\"\"", "def", "asNFA(self):", "return", "self", "def", "asDFA(self):", "return", "_DFAfromNFA(self)", "def", "states(self):", "visited", "=", "set()", "unvisited", "=", "set(self.initial)", "while", "unvisited:", "state", "=", "arbitrary_item(unvisited)", "yield", "state", "unvisited.remove(state)", "visited.add(state)", "for", "symbol", "in", "self.alphabet:", "unvisited", "|=", "self.transition(state,symbol)", "-", "visited", "def", "pprint(self,output=sys.stdout):", "\"\"\"Pretty-print", "this", "NFA", "to", "an", "output", "stream.\"\"\"", "for", "state", "in", "self.states():", "adjectives", "=", "[]", "if", "state", "in", "self.initial:", "adjectives.append(\"initial\")", "if", "self.isfinal(state):", "adjectives.append(\"accepting\")", "if", "not", "[c", "for", "c", "in", "self.alphabet", "if", "self.transition(state,c)]:", "adjectives.append(\"terminal\")", "if", "not", "adjectives:", "print", ">>output,", "state", "else:", "print", ">>output,", "state,", "\"(\"", "+", "\",", "\".join(adjectives)", "+", "\")\"", "for", "c", "in", "self.alphabet:", "for", "neighbor", "in", "self.transition(state,c):", "print", ">>output,", "\"", "--[\"", "+", "str(c)", "+", "\"]-->\",", "neighbor", "def", "RegExp(self):", "\"\"\"Convert", "to", "regular", "expression", "and", "return", "as", "a", "string.", "See", "Sipser", "for", "an", "explanation", "of", "this", "algorithm.\"\"\"", "#", "create", "artificial", "initial", "and", "final", "states", "initial", "=", "object()", "final", "=", "object()", "states", "=", "{initial,final}", "|", "set(self.states())", "#", "2d", "matrix", "of", "expressions", "connecting", "each", "pair", "of", "states", "expr", "=", "{}", "for", "x", "in", "states:", "for", "y", "in", "states:", "expr[x,y]", "=", "None", "for", "x", "in", "self.states():", "if", "x", "in", "self.initial:", "expr[initial,x]", "=", "''", "if", "self.isfinal(x):", "expr[x,final]", "=", "''", "expr[x,x]", "=", "''", "for", "x", "in", "self.states():", "for", "c", "in", "self.alphabet:", "for", "y", "in", "self.transition(x,c):", "if", "expr[x,y]:", "expr[x,y]", "+=", "'+'", "+", "str(c)", "else:", "expr[x,y]", "=", "str(c)", "#", "eliminate", "states", "one", "at", "a", "time", "for", "s", "in", "self.states():", "states.remove(s)", "for", "x", "in", "states:", "for", "y", "in", "states:", "if", "expr[x,s]", "is", "not", "None", "and", "expr[s,y]", "is", "not", "None:", "xsy", "=", "[]", "if", "expr[x,s]:", "xsy"], "content_hash": "684f797187d0b1c2f0c021c54db6fa06"}